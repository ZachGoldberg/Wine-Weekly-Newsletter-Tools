<?xml version="1.0" ?>

<kc>
<title>Kernel Cousin Wine</title>
<author email="eric.pouech@lemel.fr">Eric Pouech</author>
<issue num="59" date="04 Sep 2000 00:00:00 -0800" />

<intro>

<p />

This is the 59th release of the Wine's kernel cousin
publication. Its main goal is to distribute widely what's
going on around Wine (the Un*x Windows emulator).

<p />

Jutta Wrage announced that the latest version of the Wine-HOWTO is
available at
<a href="http://www.la-sorciere.de/Wine-HOWTO/index.html">
http://www.la-sorciere.de/Wine-HOWTO/index.html</a>
</intro>

<stats posts="66" size="214" contrib="27" multiples="16" lastweek="14">
<person posts="6" size="14" who="Dmitry Timoshkov &lt;dmitry@sloboda.ru&gt;" />
<person posts="5" size="13" who="Eric Pouech &lt;Eric.Pouech@wanadoo.fr&gt;" />
<person posts="5" size="11" who="Alexandre Julliard &lt;julliard@winehq.org&gt;" />
<person posts="5" size="10" who="gerard patel &lt;g.patel@wanadoo.fr&gt;" />
<person posts="5" size="10" who="David.Goodenough@dga.co.uk" />
<person posts="4" size="14" who="Gavriel State &lt;gav@transgaming.com&gt;" />
<person posts="3" size="8" who="lawson_whitney@juno.com" />
<person posts="3" size="8" who="Dimitrie O. Paun &lt;dimi@cs.toronto.edu&gt;" />
<person posts="3" size="38" who="David Howells &lt;David.Howells@nexor.co.uk&gt;" />
<person posts="3" size="17" who="Albert den Haan &lt;oponvybl@umail.corel.com&gt;" />
<person posts="3" size="10" who="Jeremy White &lt;jwhite@codeweavers.com&gt;" />
<person posts="2" size="6" who="Osvaldo Fornaro &lt;ofornaro@exa.unicen.edu.ar&gt;" />
<person posts="2" size="6" who="Patrik Stridvall &lt;ps@leissner.se&gt;" />
<person posts="2" size="5" who="Marcus Meissner &lt;marcus@jet.franken.de&gt;" />
<person posts="2" size="4" who="Andreas Mohr &lt;a.mohr@mailto.de&gt;" />
<person posts="2" size="3" who="Ove Kaaven &lt;ovehk@ping.uio.no&gt;" />
</stats>


<section 
  title="Page Maker and thunks"
  subject="Thunking problem is partially solved"
  archive="http://www.integrita.com/cgi-local/lwgate.pl/WINE-DEVEL/archives/2000-08/Subject/article-303.html"
  posts="8"
  startdate="28 Aug 2000 00:00:00 -0800"
  enddate="31 Aug 2000 00:00:00 -0800"
>

<p />

Dmitry Timoshkov has been busy trying to have Page Maker up and
running. Dmitry first discovered a strange behavior: Page Maker was
crashing while using the Win95 thunks. Dmitry thought that a simple
workaround was to use -winver nt40 switch, but the program still
crashed. In fact, Page Maker guesses the Windows version from the
presence of Win95 thunks. Since Wine provides all the possible thunks
mechanisms, Page Maker is fooled.

<p />

However, by removing the Win95 thunking entry points, Dmitry got Page
Maker to come up finally. But that left the crash in Win95 thunking
unexplained. With some further investigations, Dmitry proved that the
crash was due to some bad arguments popping when the thunk is
returned.

<p />

Ulrich Weigand gave the full explanation:

<quote who="Ulrich Weigand">
The problem is that we implement thunks differently than Win95 does,
with the most important difference being that we actually have two
separate stacks per app, a 16-bit one and a 32-bit one, where Win95
has  only <b>one</b> stack:  16-bit apps have their 16-bit stack, and when
thunking to 32-bit, ESP is simply set to the appropriate 32-bit flat
pointer pointing to the current 16-bit stack location; 32-bit apps
have their 32-bit stack, and when thunking to 16-bit, a temporary SS
selector is allocated that covers the current 'window' on the 32-bit
stack. 

<p />

This means that Win95 does not in fact copy <b>any</b> arguments in
QT_Thunk and the other thunking routines; they simply stay on the
stack. Similarly, all modifications made to SP by the called routine
are preserved, so if the 16-bit routine pops N argument bytes, those
arguments will also be popped on the 32-bit stack after return of 
QT_Thunk.

<p />

We, on the other hand, have to copy arguments to the 16-bit
stack. Unfortunately, we don't know how <b>many</b> arguments to copy, thus
we copy in fact the largest possible size (i.e. from ESP to
EBP-0x40. EBP-0x40 is because the region EBP-0x40..EBP is a parameter
block for use by QT_Thunk that has to be set up by the caller). As we
don't know the actual argument size, we don't know how much to pop off
the 32-bit stack either. 

<p />

This works fine if the caller of QT_Thunk is one of the thunk stubs
generated by the MS thunk compiler (which is supposed to be the <b>only</b> 
code that ever calls QT_Thunk), because these stubs don't have any
other local variables on the stack, and return to their caller 
immediately after QT_Thunk returned.

<p />

Apparently, your app calls QT_Thunk manually, from within a routine
that does in fact care about the proper ESP value after return of
QT_Thunk. This unfortunately doesn't work with the current Wine
code. To fix this, we'd need to find out how many bytes the 
16-bit routine popped off the stack, which is currently not possible.
</quote>


<p />

Ulrich Weigand went on explaining the current difficulties of Wine
being aware of the actual size of arguments to pop off, but no
solution has been found so far.

<p />

</section>


<section 
  title="Enhanced CVS commits overview"
  subject="Generating patches from commit logs"
  archive="http://www.integrita.com/cgi-local/lwgate.pl/WINE-DEVEL/archives/2000-08/Subject/article-307.html"
  posts="6"
  startdate="29 Aug 2000 00:00:00 -0800"
  enddate="30 Aug 2000 00:00:00 -0800"
>

<p />

Dimitrie Paun proposed some ideas to enhance CVS commits follow up:

<quote who="Dimitrie Paun">For the longest time I wanted to be able to look
at some of the changes that make it into the repository. It is a great 
way to review code, follow the latest changes, and understand/learn
new code areas.

<p />

For the time being, one can (partially) do that by reading the diffs
sent out by Alexandre with each release. However, they are _very_ big,
and one cannot easily separate the logical changes from one another.

<p />

Instead, what I was looking for was more on the lines of somehow being
able to easily look at the diff associated with any of the email
messages sent to wine-cvs list. That is, have a link sent out together 
with the message on which I can click to view the respective diff.

<p />

Now, wanted this feature so badly that I actually went ahead and
implemented it! :))) Here is the idea: 
<ul>
	<li>generate an ID for each message sent out</li>
	<li>include it in the message along with a summary of
changes</li>
	<li>include a link in the message that passes to a CGI program
the ID of the commit</li>
	<li>the CGI program searches the commitlog, extracts the
summary info and generates the patch</li>
</ul>
</quote>


<p />

Such a message could look like (examples are from Dimi's production
site):
<quote who="Dimitrie Paun">

<p>

<code>
ChangeSet ID: 967585195303215279709548<br />
CVSROOT: /usr/local/cvsroot<br />
Module name: evolve-client<br />
Changes by: fchung@redpill.redcelsius.on.ca. 00/08/29 17:39:55<br />
<br />
Modified files:<br />
&#160;com/esolutions/mdl/dbaccess: AbstractUpdater.java<br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
ClientUpdater.java<br />
&#160;com/esolutions/mdl/logger:&#160;CreateLog_XML.java<br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
LogRecord.java&#160;UpdateLog.java<br />
<br />
Log message:<br />
&#160;&#160;&#160;&#160;Sync: fixed problem when there are more than one meta columns with the same table/field names in a meta object.<br />
<br />
Patch:<br />
http://cvs/patch?root=/usr/local/cvsroot&amp;logs=/usr/local/cvsroot
/CVSROOT/evolvelog&amp;id=967585195303215279709548<br />
<br />
Revision&#160;&#160;Changes&#160;&#160;&#160;&#160;Path<br />
&#160;1.19&#160;&#160;&#160;&#160;&#160;+38&#160;-20&#160;&#160;&#160;&#160;evolve-client/com/esolutions/mdl/dbaccess/AbstractUpdater.java<br />
&#160;1.8&#160;&#160;&#160;&#160;&#160;&#160;+4&#160;-2&#160;&#160;&#160;&#160;&#160;&#160;evolve-client/com/esolutions/mdl/dbaccess/ClientUpdater.java<br />
&#160;1.9&#160;&#160;&#160;&#160;&#160;&#160;+88&#160;-125&#160;&#160;&#160;evolve-client/com/esolutions/mdl/logger/CreateLog_XML.java<br />
&#160;1.4&#160;&#160;&#160;&#160;&#160;&#160;+7&#160;-7&#160;&#160;&#160;&#160;&#160;&#160;evolve-client/com/esolutions/mdl/logger/LogRecord.java<br />
&#160;1.7&#160;&#160;&#160;&#160;&#160;&#160;+23&#160;-20&#160;&#160;&#160;&#160;evolve-client/com/esolutions/mdl/logger/UpdateLog.java<br />
</code>

</p>

</quote>


<p />

No strong objections appeared, but some polish may be needed even if
Dimi runs his script on a production site, mainly around server load.
We'll keep you posted if this feature is put in place.
</section>


<section 
  title="Scanner support"
  subject="Implementing TWAIN support in Wine"
  archive="http://www.integrita.com/cgi-local/lwgate.pl/WINE-DEVEL/archives/2000-08/Subject/article-331.html"
  posts="1"
  startdate="31 Aug 2000 00:00:00 -0800"
  enddate="31 Aug 2000 00:00:00 -0800"
>

<p />

Jeff Tranter made the following announcement:
<quote who="Jeff Tranter">
I want to give a heads up on some Wine development we are doing, in
case anyone else is looking at something similar or wants to help.

<p />

We would like to implement support for scanners. The Windows way to do
it is with TWAIN. The native Linux way to do it is with SANE. We're
looking at implementing the TWAIN API in Wine on top of SANE. A co-op
student here spent a few weeks researching this and has some prototype
code. His research identified a number of design issues:
<ol>
	<li>TWAIN implements a graphical user interface. There are two
different approaches that could be used for implementing it:
	<ol>	
		<li>Implement the UI as WIN32 code in Wine</li>
		<li>Use an external SANE application like xscanimage</li>
	</ol>
We are leaning towards the first option because it will support the
same look and feel as Wine, avoid legal issues with using SANE code,
and keep everything under our control. But this leads to the next
issue...</li>
	<li>TWAIN devices typically have a custom UI for each device,
provided by the vendor. The SANE approach is to poll the device for its
capabilities and dynamically build up the UI. This means the UI only
has to be implemented once, but it is more work.</li>
	<li>There are a fixed number of device capabilities specified
by the TWAIN Specification. However, device capabilities are dynamic
in SANE and there isn't a standard about the capability names. It
would be difficult to negotiate capabilities in TWAIN given that we
don't know what capabilities a SANE driver would provide. One possible
solution is to use a device configuration file to describe the mapping
between capabilities supported by a SANE driver and those specified by
TWAIN.</li>
	<li>We have to check the legal issues with using the TWAIN
header file and linking with the SANE library.</li>
</ol>

<p />

We have some prototype (alpha quality) code. It currently doesn't do
very much. It is in our current corelwine CVS in dlls/twain but is not
normally enabled. You're welcome to look at it.

<p />

A work term report should be coming in the next couple of weeks that
will document more of what was done and where the work can proceed
from here. We expect someone else at Corel will be assigned to
continue this work.
</quote>


<p />

That's good news for Wine, it will further extend the Wine
capabilities. So, if you're interested in this area, feel free to help 
polishing/testing the work underway.</section>


<section 
  title="A way to speed up Wine"
  subject="Possibility for massive wineserver speedup"
  archive="http://www.integrita.com/cgi-local/lwgate.pl/WINE-DEVEL/archives/2000-08/Subject/article-309.html"
  posts="3"
  startdate="29 Aug 2000 00:00:00 -0800"
  enddate="29 Aug 2000 00:00:00 -0800"
>

<p />

David Howells posted a thread that may end up in re-architecturing
Wine (a bit):
<quote who="David Howells">
I've made a start on a kernel module implementing some wineserver-type
functionality, and I think that I've reached a reasonable point to put it up
for discussion.

<p />

At the moment it does the following:
<ul>
   <li>CreateEvent</li>
       <li> OpenEvent</li>
        <li>PulseEvent</li>
        <li>ResetEvent</li>
        <li>SetEvent</li>
        <li>CreateMutex</li>
        <li>OpenMutex</li>
        <li>ReleaseMutex</li>
        <li>CreateSemaphore</li>
        <li>OpenSemaphore</li>
        <li>ReleaseSemaphore</li>
        <li>WaitForMultipleObjects (mostly)</li>
        <li>CloseHandle</li>
</ul>

<p />

Unfortunately, it can't actually be integrated into Wine just yet, since it
only supports three of the many 'kernel' object types, and WaitFor*() can't be
shared between implementations.
</quote>


<p />

Even if first benchmarks are promising (3% over Win2000, up to 20% for
some test programs over Win2000 ; 900% over current Wine
implementation).

<p />

Of course, this has to be studied in details (test programs are not
real life programs, so your mileage may vary ; how can this be ported
/ maintained across non Linux platforms).

<p />

Anyway, it opens the door to Wine's speed improvement (at least 900%
can be achieved on low level synchornization) and WWN will surely
cover the first bits of the technical discussion next week. xs
</section>

</kc>
