<?xml version="1.0" ?>
<kc>

<title>Wine Traffic</title>

<author contact="http://www.theshell.com/~vinn">Brian Vincent</author>
<issue num="257" date="01/14/2005" />
<intro> <p>This is the 257th issue of the Wine Weekly News publication.
Its main goal is to write. It also serves to inform you of what's going on around Wine. Wine is an open source implementation of the Windows API on top of X and Unix.  Think of it as a Windows compatibility layer.  Wine does not require Microsoft Windows, as it is a completely alternative implementation consisting of 100% Microsoft-free code, but it can optionally use native system DLLs if they are available.   You can find more info at <a href="http://www.winehq.org">www.winehq.org</a></p> </intro>
<stats posts="255" size="873" contrib="72" multiples="45" lastweek="39">

<person posts="14" size="44" who="Mike McCormack" />
<person posts="13" size="30" who="Alexandre Julliard" />
<person posts="13" size="41" who="Robert Shearman" />
<person posts="22" size="64" who="Mike Hearn" />
<person posts="10" size="45" who="Joris Huizer" />
<person posts="10" size="34" who="Paul Vriens" />
<person posts="10" size="27" who="Dimitrie O. Paun" />
<person posts="8" size="26" who="Francois Gouget" />
<person posts="7" size="24" who="Dmitry Timoshkov" />
<person posts="7" size="17" who="Paul Vriens" />
<person posts="6" size="20" who="Jason Edmeades" />
<person posts="6" size="18" who="Ferenc Wagner" />
<person posts="5" size="24" who="Jeremy White" />
<person posts="5" size="20" who="Bill Medland" />
<person posts="5" size="16" who="Paul Millar" />
<person posts="5" size="11" who="Vitaly Lipatov" />
<person posts="4" size="30" who="Robert Reif" />
<person posts="4" size="26" who="Con Kolivas" />
<person posts="4" size="24" who="Ivan Leo Puoti" />
<person posts="4" size="15" who="Jonathan Ernst" />
<person posts="4" size="13" who="Hiji" />
<person posts="4" size="12" who="Christian Costa" />
<person posts="4" size="12" who="Stefan D&#246;singer" />
<person posts="4" size="12" who="Paul van Schayck" />
<person posts="4" size="12" who="Tony Lambregts" />
<person posts="4" size="9" who="Andreas Mohr" />
<person posts="4" size="9" who="Steven Edwards" />
<person posts="3" size="11" who="Raphael" />
<person posts="3" size="10" who="Vincent B&#233;ron" />
<person posts="3" size="9" who="Dripple" />
<person posts="3" size="8" who="Dan Kegel" />
<person posts="3" size="7" who="Oliver Stieber" />
<person posts="2" size="8" who="Ove Kaaven" />
<person posts="2" size="7" who="Stefan Leichter" />
<person posts="2" size="7" who="Jason But" />
<person posts="2" size="7" who="Nick Hornback" />
<person posts="2" size="6" who="Scott Ritchie" />
<person posts="2" size="6" who="FyD" />
<person posts="2" size="6" who="Jeremy Newman" />
<person posts="2" size="5" who="Remi Assailly" />
<person posts="2" size="5" who="Brian Vincent" />
<person posts="2" size="5" who="Hans Leidekker" />
<person posts="2" size="5" who="Jakob Eriksson" />
<person posts="2" size="4" who="Ge van Geldorp" />
<person posts="1" size="18" who="Naren" />
<person posts="1" size="9" who="Chris Morgan" />
<person posts="1" size="6" who="Crestez Leonard" />
<person posts="1" size="4" who="Stefan Zechmeister" />
<person posts="1" size="3" who="Victor Antolini" />
<person posts="1" size="3" who="Michael G&#252;nnewig" />
<person posts="1" size="3" who="Shachar Shemesh" />
<person posts="1" size="3" who="=?ISO-8859-1?Q?Andr=E9_Goddard_Rosa?=" />
<person posts="1" size="3" who="Robert North" />
<person posts="1" size="3" who="Michael Stefaniuc" />
<person posts="1" size="3" who="Juan Lang" />
<person posts="1" size="2" who="Bryce McKinlay" />
<person posts="1" size="2" who="Tony Lambregts" />
<person posts="1" size="2" who="Eric Pouech" />
<person posts="1" size="2" who="Kevin Koltzau" />
<person posts="1" size="2" who="Heiko Nardmann" />
<person posts="1" size="2" who="Rolf Kalbermatter" />
<person posts="1" size="2" who="Dan Notestein" />
<person posts="1" size="2" who="gslink" />
<person posts="1" size="2" who="James Hawkins" />
<person posts="1" size="2" who="Tobias Burnus" />
<person posts="1" size="2" who="Scott W Gifford" />
<person posts="1" size="2" who="Boaz Harrosh" />
<person posts="2" size="4" who="Gerald Pfeifer" />

</stats>
<section 
	title="News: Wine-20050111" 
	subject="News"
	archive="http://www.winehq.com/announce/20050111"
	posts="1"
	startdate="01/08/2005"
	enddate="01/14/2005"
>
<topic>News</topic>
<p>Alexandre released a Wine snapshot this week.  Changes include:</p>

<quote who="Alexandre Julliard"><p>

WHAT'S NEW with Wine-20050111: (see 
<a href="http://cvs.winehq.com/cvsweb/wine/ChangeLog?rev=1.90&amp;content-type=text/x-cvsweb-markup">ChangeLog</a> for details)
<ul>
        <li> Many OLE bug fixes and improvements.</li>
        <li> A lot more work on the MSI dll.</li>
        <li> Update regions now handled in the Wine server.</li>
        <li> Beginnings of typelib generation in the IDL compiler.</li>
        <li> Many janitorial cleanups.</li>
        <li> Lots of bug fixes.</li>
</ul></p></quote>

<p>In the days since then, there's been a lot of commits to CVS,
more so than usual.  You might want to 
<a href="http://www.winehq.com/cvs">use CVS</a> to stay up to date.
If you'd like to 
<a href="http://www.winehq.com/download">download a binary</a> though,
you can find them for most popular distributions.  
</p>
</section>
<section
        title="Direct3D Update and Roadmap"
        subject="Directx 9"
        archive="http://www.winehq.org/hypermail/wine-devel/2005/01/0210.html"
        posts="3"
        startdate="01/08/2005"
>
<topic>DirectX</topic>
<p>Jason Edmeades posted another patch for DirectX.  For the past few
months he's been working on creating a new library called <i>wined3d</i>,
moving D3D functionality into it, and implementing DirectX 9 on top.
With his latest patch, he noted the following changes:</p>
<quote who="Jason Edmeades"><p>
This clears out the next blocking part of the d3d9 / wined3d support and has
been a real pain to implement. I think I've got it right now, and it adds
support for render targets but more importantly the beginnings of a front
and back buffer which a lot of the code relied upon.
</p><p>
Unfortunately I couldn't get this next step any smaller than the patch
attached....
</p><p>
Major areas still to go - textures and pixel / vertex shader support. I'm
moving onto the textures next...
</p><p>
Changelog
<ul>
Add render target support, and ensure there is a front and back buffer
created during device creation</ul></p>

</quote>
<p>Oliver Stieber wrote in to say he'd worked on some of the same 
areas:</p>
<quote who="Oliver Stieber"><p>
 I've just done more-or-less exactly the same this
weekend with a couple of differences.
</p><p>
I've merged all the creation surface code into a
single createSurface function that is called with
different parameters/flags to create a backbuffer,
PlainOffscreenSurface or rendertarget etc...
</p><p>
This should mean that you only require one call-back
function for CreateDevice in WineD3D.
</p><p>
I'll merge your patch with what I've got and see how
it goes.
</p><p>
As soon as I'm happy with how wine's and directX work
I can stop duplicating what you've done and start
moving onto a more co-operative development, or moving
DirectX8 over to using WineD3d.
</p><p>

So far I can run Pirates! and a few of the demos from
<a href="http://www.codesampler.com/dx9src.htm">
http://www.codesampler.com/dx9src.htm</a>, but without
textures.
</p><p>
Pirates uses DirectX 9c but doesn't do anything too
fancy and runs without crashing so it seems good for
testing.
</p><p>
Many of the demos at
<a href="http://www.codesampler.com/dx9src.htm">
http://www.codesampler.com/dx9src.htm</a> have OpenGL
versions and since I don't know OpenGL or DirectX (but
can hack a good Dos demo) it seemed a good place to start.
</p></quote>

<p>(Pirates! working?!?!)</p>

<p>Jason wrote back to give Oliver an idea of 
how he was planning on tackling the rest of the work
for wined3d:</p>

<quote who="Jason Edmeades"><p>
I've spent the last couple of months putting together a directx 8 level
support into wined3d and calling it from d3d9 such that I can also change
d3d8 easily to use the new code. This is mostly complete other than the
texture support and the shader support plus moving some functions / stubs
into the common code.
</p><p>
If you have any directx 8/9 questions feel free to email me directly, put
questions on wine-devel or perhaps even the wined3d (very, very quiet -
http://www.bbrox.org/mailman/listinfo/wine-d3d) mailing list (Lionel's). You
really are welcome, and I'll try to answer any questions I can.
</p><p>
I wouldn't spent too much time trying to move existing functionality between
d3d8 to wined3d unless you really want to as I am trying to get this move
completed asap. I really don't want to discourage any d3d assistance, it's
just I know where I am and what I have left to do.
</p><p>
I have generally been doing a patch and getting it committed both due to
lack to time, but also to avoid potential rework of multiple patches. I
really hope to get most of the non-shader support done quite quickly once
the 20 patch goes in (Christmas and FarCry got in the way, and I had some
teething problems with the render target support which delayed it!). Next
will be the texture support and that should be quick as it is relatively
trivial to move across.
</p><p>
One thing wine has suffered from is a lack of people doing the
directx support! Note that Raphael (copied on this note) has some
outstanding patches he has put off while I do the move to support hardware
vertex buffers so the drawstridedslow case is driven less frequently, but
that's the only outstanding work I know about.
</p><p>
I have a version locally where I have changed d3d8 up to about patch 13. I
can send it to you if it helps - Unfortunately I think the swap to wined3d
will have to be one big patch, I don't think there is a way to move d3d8
over slowly, as you have to move the state block code in one go, the
resource8 subclasses in one go etc...
</p><p>
The problem I had with the latest patch was purely being able
to add the support for getfrontbuffer etc which needed to return d3d8 or
d3d9 objects, but the initial creates being done in the wined3d layer. A
single callback sounds useful, as I know I'll have to do something similar
for stencildepth surfaces (nothing else is created purely from the wined3d
layer, so I don't think others need the same).
</p><p>
FWIW I do the same, ie find demos on the web with source code, and then try
to get them working. That's how most of the d3d8 support came about as it's
a lot easier making a demo work than finding why there's a small amount of
corruption for a particular game. I wouldn't claim to be a directx nor
opengl expert - it's all been a learning experience as I go! Maybe we should
collect some useful test program links!
</p><p>
If there's any d3d8/9 programmers out there, there's definitely a fun
project to do to produce test programs for wine. They can't be automated (I
think!) but it would be useful to be able to visually see the effect
differences of all the render states, the texture states, prove the shader
support works in both hw and sw vertex and pixel code etc etc. 
</p></quote>



</section>

<section
        title="Wine and Scheduling"
        subject="Re: [ck] Re: Threading issues? [ck-request@vds.kolivas.org: ck Digest, Vol 3, Issue 16]"
        archive="http://www.winehq.org/hypermail/wine-devel/2005/01/0331.html"
        posts="15"
        startdate="01/09/2005"
	enddate="01/14/2005"
>
<topic>Integration</topic>

<p>Some discussion carried over to wine-devel about improving
performance of Wine on Linux.  At the heart of the matter is
how much different Linux is compared to Windows at scheduling
processes to run.  Andi Mohr pointed out a recent thread that
started on a kernel mailing list (Con Kolivas').  Con
suggested that to improve performance,
<quote who="Con Kolivas">
Nice your wineserver +19. If that's not enough, just run wine at +19.
Wineserver gets into a silly priority inversion scenario with the main
wine threads.</quote>
</p>

<p>Andi thought it was worth bringing up to Wine's developers:</p>
<quote who="Andreas Mohr"><p>
Note that Con indicated several times that Wine is a very "special" piece
of software, it has wildly differing gaming behaviour (threading behaviour)
than native Linux games.
</p><p>
For those of you who don't know what priority inversion is (I'll try to
explain it, but I'm sure my explanation sucks ;):
one (high priority) thread is waiting on a lock, and in order to keep
this high priority, another thread owning that lock gets more CPU to
get that lock released. Problem is that that thread should have a
lower priority, but since the high priority thread always has to wait on
the lock, the low priority thread effectively has a much higher priority.
</p><p>
These could just be the usual known slow wineserver communication effects
at work here, but I wanted to make sure you know about these issues on the
CK list.</p></quote>

<p>CodeWeavers looked into this problem just a few months
ago and Jeremy White was all too familiar with it:</p>
<quote who="Jeremy White"><p>

I suspect that the issue is much deeper than just the
wineserver effects; Windows scheduling requirements
are fundamentally different than the scheduling that the
Linux kernel tries to supply, and the differences
can be hard to troubleshoot.
</p><p>
Photoshop, for example, relies on the ability of a
thread to Sleep for precisely 5 ms, and then wake up in a certain
priority state.  The Linux kernel inverts that
(I forget the exact details, but we dug into this
in great detail this past fall), and so the Photoshop
thread has a great deal of difficulty.  AFAIR, we had
issues with the thread sleeping for 115 ms instead of
5 ms, and we alternately had problems with the thread starving
other threads in the system, so that nothing else was
being served.
</p><p>
On my todo list is an item to start a conversation with
the Kernel guys about these scheduling differences,
and to see if we can ask for a few tuning hooks to help
us better match Windows.  But I keep trying to goad
Alexandre into doing it, and he keeps reminding me that
I'm not supposed to bother him with anything until after
the Window Manager rewrite is done... &lt;grin&gt;.</p></quote>

<p>Jeremy put together a detailed list of the problems
he found and posted it to Con's mailing list:</p>
<quote who="Jeremy White"><p>
I spent a great deal of time this past fall exploring Wine scheduling
issues, and I thought I would post what I learned.
</p><p>
The most critical point is Wine was pretty badly broken;
it simply had a number of flaws in how scheduling was done.
</p><p>
First, the winmm timer, used by a lot of programs,
was pretty awful.  That has now been fixed, and I believe
that it now works correctly.
</p><p>
Second, we did not synchronize Wine message times with X11
message times properly.  Fixing that resolved some issues
with Photoshop (and given that Ove reworked that patch into
WineX the same day I submitted it, I'd guess it fixed some
games too &lt;grin&gt;).
</p><p>
Third, Wine did not yield the processor properly at points
where Windows does, including Sleep(0) and certain event
conditions.  That's now been (mostly) fixed, I think.
</p><p>
Fourth, the Wine server had an issue with the way it managed
it request queues.  To be honest, I don't understand this
bug or the fix; all I know is that Mike McCormack figured
this one out and posted a magic fix.  This was, I believe,
the primary reason that the wineserver would chew 100% cpu
with iTunes.
</p><p>
Beyond that, there are a number of ways that Wine
'gets lucky' and Just Works (TM) works on the Linux scheduler,
in ways that we couldn't have asked for.
</p><p>
First, because many Wine calls resolve into a wineserver
call, and a wineserver call involves a write to a pipe,
we potentially risk yielding the processor far more often
in Wine that a Windows program would 'naturally' do so
on Windows; opening us to horrendous timing bugs.
However, in practice, because the Wine server often
handles requests within a single quanta, and because waiting
on a pipe with data gets a priority boost in Linux,
the net effect is what Wine wants.  (Thread A makes a request,
yields to the Wine server who gets in ahead of all other threads,
does the requests, sends the response back, and Thread A regains
control before any other Wine thread because it got a priority boost).
</p><p>
Second, the new 2.6  average time quanta of 100 ms is comparable
to the observed Windows quanta of 115 ms (I may have that wrong,
but I recall they were quite close), although the old, much
smaller time quanta masked a number of Wine scheduling problems.
But, in theory, having this longer time quanta should let us
better replicate Windows scheduling behavior.
</p><p>
However, we still have some issues.  First, the problem with
thread priorities still remains an issue.  A non zero number
of important applications rely on Windows priorities to
change timing behavior to make their applications run properly.
([editors note:  imho, these are poorly written apps, but
we have to support them as they are; wishing that MS would
rewrite PowerPoint to my spec is amongst the most futile things I can
imagine]).
</p><p>
There is a patch Mike worked up which makes a theoretical
improvement to the Wine server (pull requests from its queue
in thread priority order), but we have no evidence that
change makes any difference, and Mike backed away from it
when he found the afore mentioned 'correct' fix.
Nonetheless, I think it is conceptually 'right', so we probably
should bug Mike into redoing that patch.
</p><p>
I've played with a number of artificial ways to try to replicate
this within Wine, and have come up with a few compromises, but
nothing works perfectly (or, more importantly, worked up
nothing that Alexandre would apply &lt;grin*gt;).  If you do try to exactly mirror
Windows priorities, for example (running as root, say), you run
into issues where the wineserver gets starved and Wine stops
functioning.
</p><p>
Candidly, that's where I'm stuck.  I'm going to revisit a few
of my 'problem' apps hopefully sometime this year and see if I can
cobble together a hack that works best.  Ove, I haven't
tried the signalling approach; that seems like an interesting idea.
</p><p>
Sadly, short of asking the Linux guys to rewrite the Linux kernel
scheduler to exactly mimic Windows behavior, I'm not really
sure if there is a lot we can do to get this exactly right.
</p></quote>

<p>Con thanked Jeremy for explaining all this and asked for
some more info to see if he could help,
<quote who="Con Kolivas">
 Well the scheduler is not going to be rewritten any time soon (trust me, 
 I've tried :P). Tell me what remaining requirements your threads have 
 that you are unable to achieve at the moment and I'll see if I can help 
 with my understanding of the priority system as it is, in a generic way 
 that hopefully will work across scheduler designs.
</quote></p>

<p>Jeremy went back and explained more issues Wine runs into:</p>
<quote who="Jeremy White"><p>
At this point, I think the only glaring hole we have is the issue of
thread priorities.  That seems to be a capability we simply can't
accurately replicate in Wine.  My hope is that if we can somehow
mock that up (or address the few dodgy cases where it's a problem),
we won't face any other timing issues.
</p><p>
 From there, I think the honest truth is that I have more homework to do;
we tend to take the pragmatic approach that a theoretical problem is
uninteresting until we have real apps with real unsolvable problems.
So I need to go find some more problem cases and understand them.
</p><p>
In the interest of making this thread complete, I wanted to add
a concern or two I forgot, and to belabor a point or two
(that's your clue to tune out now, folks &lt;grin&gt;).
</p><p>
Specifically, there are other areas of interest when you think about
timing and scheduling.  First is the Windows very clear cut 'foreground
window' boost.  I have no idea how this maps into the Linux
interactivity strategy.  They seem to be roughly equivalent, and I
never found an application that relied on that timing.
</p><p>
Second, the exact sequence of when a thread
yields or not on Windows is not something I'm sure I fully learned; I did
my best, but my gut tells me that I must have missed some cases.
The main trick as we make sys calls here is to make sure that we don't accidentally
yield at times when Windows wouldn't.
</p><p>
That connects to the theoretical flaw in Wine (the whole use of the
Wine server) that should make us vulnerable to all sorts of
unexpected context switches, creating timing patterns unfamiliar
to Windows applications, and causing problems.  And yet,
from observation, I never see any such unexpected context switches.
The Linux kernel priority boost for pipes seems to protect us here;
we should make sure we understand why and let the kernel guys know that
we depend on it, so they don't knock it out from under us some day.
</p><p>
Fourth, based on your reply to my earlier email, I suspect I do
not understand how time quanta are assigned.  In fact, I had come to
some conclusions at one point last fall, that I can no longer
convince myself of (I was persuaded that a thread that constantly
yielded had it's time quanta dranstically reduced; I can no longer
reproduce that).  Further, time quanta differences can be crippling to Wine.
Photoshop, for example, relies on reliable 5ms timing, and if it doesn't
get it, it doesn't work.  Similarly, I could swear I had a problem
case in IE where two threads were interdependent, and the one thread
never got a large enough quanta to keep the second thread happy (and
this then caused a spiral that led to the small quanta for thread A).
Sadly, I didn't take good notes, so I have to go back and relearn that case
again.  And, knowing me, I probably completely misunderstood it anyways :-/.
</p><p>
Sorry to ramble on; it's just tough around here, because everyone
is tired of hearing me claim that every bug is a timing problem...</p></quote>

<p>Con went through these point by point.  Regarding the "foreground
window gets a priority boost" issue, Con pointed out,
<quote who="Con Kolivas">
We do nothing of the sort. There is no special casing in the kernel for 
any processes that aren't kernel threads. However, the more frequently a 
task sleeps, the more priority it is rewarded with. That tends to select 
out interactive tasks.</quote></p>

<p>Regarding something like Photoshop requiring a specific 
timeslice,
<quote who="Con Kolivas">What you are saying is it needs at least 5ms 
timeslice on hardware that is equal to or faster than the machine you 
tested it on. We cannot guarantee any timeslice of any size will occur 
uninterrupted in the linux kernel. For tasks that are not nice'd, the 
usual minimum slice is 10ms. But if something higher priority than it 
wakes up in the interim, it will be preempted even if it is 50 
microseconds into its timeslice.</quote></p>


<p>Jeremy described the Photoshop problem in detail:</p>
<quote who="Jeremy White"><p>
Your typical Photoshop user relies on the fact
that Photoshop is the only application of any priority on the machine;
Photoshop has a thread that runs that samples the mouse position every 5 ms;
if it doesn't get it's samples in the right amount of time, you don't
draw smooth curves.  (It may be a timer event callback routine,
or a thread that is woken up by a timer event, I can't recall exactly atm).
</p><p>
I suspect that if you start a heavy compile on a Windows box, Photoshop
won't paint right, just as it wouldn't if you burdened the CPU on Linux.
</p><p>
What we need to protect is the apples to apples case - when Photoshop
is the only app using the CPU with Wine, it needs to draw smoothly, and for that,
it needs to know that the thread it has marked as super duper high
priority will get run every 5 ms as it has requested.
</p><p>
(My gut reaction to this was that it was horrid programming on Adobe's
part; but they are trying to provide extremely fine resolution on drawing,
and their approach makes sense in that context.  I am now persuaded
of their competence &lt;g&gt;).</p></quote>

<p>Con's reaction seemed to be, it's as good as it's going to get
for Wine,<quote who="Con Kolivas">
Right. Well the tasks that sleep the most on linux get the lowest 
latency and the best cpu guarantees. Unless this same thread is also 
doing lots of cpu on linux it should work fine with 10ms granularity. 
However this sort of coding is so not-portable... but that's another 
issue. They never had portability in mind when they coded it.</quote></p>

<p>The other problem with IE and two different threads trying to
synchronize sounded familiar to Con:</p>
<quote who="Con Kolivas"><p>
This is not at all unusual. If there is no locking between threads, and 
you simply hope that one will complete in time for the other, you will 
get various degrees of priority inversion. Native linux applications do 
it too, and 2.6 has forced them to improve their coding principles (see 
the thread on 'blender' in the linux kernel mailing list during 2.5 
development. There are various algorithms that have been tried to detect 
when this is happening and inherit appropriate priorities, but they have 
their own overhead and aren't as effective as proper blocking in the 
first place.</p><p>
Generous use of blocking where appropriate is the answer to being 
friendly to any scheduler. Hoping dependent threads will complete in 
time is futile as the speed of execution of each thread will change on 
different schedulers, hardware etc.
</p></quote>

<p>Ove K&#229;ven jumped in to describe something he'd like to
see in the kernel that would definitely improve things for Wine
(and WineX in his case):</p>
<quote who="Ove Kaaven"><p>
The biggest problem is that there is no way to say to the kernel that
one thread is more important than another without permanently renicing
all other threads. A potential kernel solution to the problem would be
to implement process scoping in the kernel, i.e.
<ul><code>
pthread_attr_setscope(attr, PTHREAD_SCOPE_PROCESS)</code></ul></p><p>

and then allow threads scoped this way to be set to high priority, since
with a process scope, these threads should only preempt other threads in
the same process (i.e. Wine), not threads run by other Linux apps, and
thus the security concerns of elevated priority threads are irrelevant.
</p><p>
Allowing a process-scoped thread to set the scheduling policy to
SCHED_RR in order to inhibit the kernel's interactivity priority boost
system would also help.</p></quote>

<p>Con thought that would be pretty easy to do.  In fact, he'd already
done it, but it hadn't been included in the kernel,
<quote who="Con Kolivas">

 I had proposed a fixed priority scheduling class on the linux kernel 
 mailing list for just such an occasion. However no one noticed or seemed 
 interested. The patch is in the lkml archives and would be trivial to 
 re-implement. Would this be helpful? I know Ingo Molnar certainly saw a 
 need for such a patch after I described a different issue that could be 
 helped with it.</quote></p>

<p>This thread will likely continue on, though it appears some headway
is being made.  In fact, as this thread was going on, Alexandre committed
a patch to Wine to fix X11 event timing.  Perhaps we'll see something in 
the coming weeks to address some of these other issues.   </p>
 
</section>

<section
        title="Intro to Conformance Tests" 
        subject="Best DLLs to write conformance tests for?"
        archive="http://www.winehq.org/hypermail/wine-devel/2005/01/0224.html"
        posts="4"
        startdate="01/10/2005"
	enddate="01/13/2005"
>
<topic>Testing</topic>

<p>Dan Kegel asked for some input on improving Wine's
suite of conformance tests:</p>
<quote who="Dan Kegel"><p>
Recently, I helped a student at Harvey Mudd college
write and submit a conformance test for the lzexpand dll:
<a href="http://www.winehq.com/hypermail/wine-cvs/2004/11/0164.html">
http://www.winehq.com/hypermail/wine-cvs/2004/11/0164.html</a>
I picked lzexpand.dll since (lacking a GUI) it seemed simple to test.
</p><p>
Now I'm putting together a reusable lab project for other
colleges, at 
<a href="http://kegel.com/wine/sweng">http://kegel.com/wine/sweng</a>, 
and am trying
to pick a few good DLLs for the students to write tests for.
(I plan ask the students to send me their patches so I can
review them before they post them on wine-patches.)
</p><p>
Clearly, I shouldn't ask anyone to write a conformance
test for a huge DLL in a term, so I guess I'll focus on
on the DLLs with under 100 functions.  And I'd like to
skip DLLs that have GUIs, so I guess I'll omit any where
the word HWND occurs. 
</p><p>
That's a small enough list that I can start guessing at
which ones are worth writing tests for.  Let's see, how
'bout the following 12:
<table>
<tr><td>amstream    </td><td>atl         </td><td>cabinet</td></tr>
<tr><td>crypt32     </td><td>dplayx      </td><td>dpnet</td></tr>
<tr><td>icmp        </td><td>imagehlp    </td><td>itss</td></tr>
<tr><td>mswsock     </td><td>winaspi     </td><td>wsock32</td></tr>
</table></p><p>
Are any of those obviously poor choices for writing
a conformance test?  Or are there others that are
obviously good choices, but that I missed?
</p></quote>

<p>Mike McCormack suggested a somewhat different approach:</p>
<quote who="Mike McCormack"><p>
Well, there's still plenty of test cases that can be written for each 
DLL.  Ideally we start from the bottom (ntdll, kernel, gdi, etc) with 
our test cases so that we can fix code in the dlls and programs that 
depend on those dlls.
</p><p>
Following that line of thought, imagehlp (used by winedbg), cabinet 
(used by msi and setupapi), wsock32 and crypt32 seem like good choices.
</p></quote>

<p>Eric Pouech corrected Mike regard imagehlp:</p>
<quote who="Eric Pouech"><p>
since most of the symbol (&amp; debug information) part of imagehlp has been moved 
to dbghelp, I'd say dbghelp might be a better candidate than imagehlp
(and winedbg uses directly dbghelp, not imagehlp)</p></quote>

<p>Dan appreciated the ideas,
<quote who="Dan Kegel">
Thanks for the info.  I've updated my list at
<a href="http://kegel.com/wine/sweng/#project3">http://kegel.com/wine/sweng/#project3</a>
</quote></p>

</section>

<section
        title="Setting Up a Scanner"
        subject="Q: porting driver for USB scanner - where to start?"
        archive="http://www.winehq.org/hypermail/wine-devel/2005/01/0394.html"
        posts="3"
        startdate="01/13/2005"
>
<topic>Integration</topic>

<p>Getting hardware to integrate with Windows programs can be
tough sometimes.  Heiko Nardmann wanted to know how to get a
USB scanner to work:</p>
<quote who="Heiko Nardmann"><p>
I want to write a linux driver for my USB scanner which is currently not yet 
supported by sane. So I wonder where to start; where do I find detailed 
information about the Windows driver interface, esp. for USB scanners. I want 
to know which interface a driver has to offer to Windows and which 
functionality the API has to offer.

</p></quote>

<p>Francois Gouget suggested:</p>
<quote who="Francois Gouget"><p>
Well I think the right solution would be to add support for your scanner 
to SANE. Then Wine should be able to use it using the twain dll (see 
dlls/twain) which acts as a bridge to SANE.
</p><p>
Interfacing directly with the scanner might work using Wine's brand new 
and very incomplete USB interface (I believe part of it is in setupapi) 
but that would probably be more code and you would still end up writing 
what is essentially a driver. In other words in either case you will 
probably need the hardware specifications.</p></quote>

</section>

<section
        title="Palm Desktop &amp; PDF Files"
        subject="Palm OS Desktop &amp; Wine"
        archive="http://www.winehq.org/hypermail/wine-devel/2005/01/0265.html"
        posts="13"
        startdate="01/10/2005"
	enddate="01/12/2005"
>
<topic>Integration</topic>

<p>Fran&#231;ois Dupradeau ran into a problem getting 
some software for Palm integration working with Wine:</p> 
<quote who="Francois Dupradeau"><p>

I have a Tungsten E PDA and use K-pilot/J-pilot to backup/restore/install
.pdb/.prc files with my linux box. No problem for that.
</p><p>
 However, I would like to install a .pdf viewer on my PDA and the files
provided for this installation are not .pdb/.prc files but a Windows executable
file (AdobeReader305-PalmOS.exe). To install this file, I need to install the
whole Palm Desktop CD under windows.
</p><p> Consequently, I thought to use Wine for that: I compiled Wine_20041201 on my
linux box (RedHat 9.0), configured it with 'winesetuptk' and run 'wine
/mnt/cdrom/autorun.exe' to install the whole Palm Desktop CD for window.
</p><p>
Is it possible to do install the 'Palm OS Desktop' CD with Wine and/or any idea
for my problem ?
</p></quote>

<p>After a somewhat annoying exchange about the merits of top-posting
vs. bottom-posting in a thread, the discussion continued on.  Stefan
D&#246;singer wrote a short guide to getting it to work:</p>
<quote who="Stefan Dosinger"><p>
A small step-for-step howto:
<ul>
<li>Install Palm Desktop.</li>

<li>install the Adobe Reader for PalmOS converter. This means running 
adobereader-palmos.exe with wine</li>

<li>Launch hotsync.exe from the directory where Palm.exe is installed. You'll get 
the hotsync icon in your Desktop's systray</li>

<li>Double-click it with the right mouse button. You'll always have to double 
click the hotsync icon to open the menu, I don't know why</li>

<li>Select the "Setup..." menu item or whatever it is called. I have the German 
version and it's labeled "Einrichten..."</li>

<li>Open the network tab, press "TCP/IP Settings". Check if the ip is correct and 
enter a correct subnet mask, e.g. 255.255.255.0</li>

<li>Press OK to close the windows</li>

<li>terminate any Linux app which might access the Palm. Connect the Palm to your 
PC with the USB cable</li>

<li>Launch the Hotsync program on your PalmOS device</li>

<li>Open the menu and select "LANSync-Setup" or what it's called. The german 
version labels it "LANSync-Einst..."</li>

<li>Select LANSync and tab OK to close the dialog</li>

<li>Start the Hotsync over the usb cable.</li>

<li>Run <tt>pi-nredir -p /dev/pilot</tt> on your computer 3 or 4 seconds later. 
The Hotsync dialog should pop up and the Device should perform a hotsync with the 
Win32 Palm Desktop.
(replace <tt>/dev/pilot</tt> with the hotsync port visor.c provides to you. 
Usually <tt>/dev/ttyUSBX</tt> or <tt>/dev/usb/tts/X</tt>)</li></ul></p><p>

To upload a pdf launch the pdf converter from it's install directory, and 
select the pdf file to upload. Then perform a hotsync.</p><p>

I hope this is correct, I wrote it down from memory.</p></quote>

<p>Some discussion about USB ensued, and Jeremy White posted
some info regarding USB configuration and iTunes:</p>
<quote who="Jeremy White"><p>
Your best resource may be:
<ul><a href="http://www.codeweavers.com/support/docs/crossover-pro/troubleshooting#ITUNES-IPOD">
   http://www.codeweavers.com/support/docs/crossover-pro/troubleshooting#ITUNES-IPOD</a></ul>
</p><p>
I think it explains the steps pretty clearly, and would be pretty useful
even to non CrossOver Wine users (don't worry about not having cxipod,
it doesn't do anything that can't be done manually, and I'm pretty sure
it's all explained).</p></quote>

</section>
</kc>
