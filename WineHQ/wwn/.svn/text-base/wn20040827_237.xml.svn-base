<?xml version="1.0" ?>
<kc>

<title>Wine Traffic</title>

<author contact="http://www.theshell.com/~vinn">Brian Vincent</author>
<issue num="237" date="08/27/2004" />
<intro> <p>This is the 237th issue of the Wine Weekly News publication.
Its main goal is to eat Vicodin. It also serves to inform you of what's going on around Wine. Wine is an open source implementation of the Windows API on top of X and Unix.  Think of it as a Windows compatibility layer.  Wine does not require Microsoft Windows, as it is a completely alternative implementation consisting of 100% Microsoft-free code, but it can optionally use native system DLLs if they are available.   You can find more info at <a href="http://www.winehq.org">www.winehq.org</a></p> </intro>
<stats posts="173" size="891" contrib="57" multiples="29" lastweek="28">

<person posts="23" size="121" who="Mike Hearn" />
<person posts="12" size="43" who="James Hawkins" />
<person posts="12" size="31" who="Alexandre Julliard" />
<person posts="11" size="44" who="Robert Shearman" />
<person posts="8" size="45" who="Shachar Shemesh" />
<person posts="8" size="23" who="Pierre d'Herbemont" />
<person posts="7" size="13" who="Ivan Leo Puoti" />
<person posts="6" size="53" who="Vincent B&#233;ron" />
<person posts="5" size="24" who="Jim White" />
<person posts="5" size="10" who="Steven Edwards" />
<person posts="4" size="47" who="Alexander Yaworsky" />
<person posts="4" size="10" who="Robert Reif" />
<person posts="4" size="10" who="Francois Gouget" />
<person posts="3" size="127" who="Tom" />
<person posts="3" size="50" who="Michael Kaufmann" />
<person posts="3" size="10" who="Tobias Burnus" />
<person posts="3" size="9" who="Dan Kegel" />
<person posts="3" size="7" who="Eric Pouech" />
<person posts="2" size="25" who="Rib Rdb" />
<person posts="2" size="7" who="Stefan Leichter" />
<person posts="2" size="6" who="Paul Millar" />
<person posts="2" size="5" who="Simon Kitching" />
<person posts="2" size="5" who="Frank Eising" />
<person posts="2" size="5" who="Mike McCormack" />
<person posts="2" size="5" who="Joris Huizer" />
<person posts="2" size="5" who="Diego Petten&#242;" />
<person posts="2" size="5" who="Zach Gorman" />
<person posts="2" size="4" who="Lionel Ulmer" />
<person posts="2" size="3" who="James Courtier-Dutton" />
<person posts="1" size="38" who="Roger Olson" />
<person posts="1" size="13" who="Marcelo Duarte" />
<person posts="1" size="6" who="Rafael Avila de Espindola" />
<person posts="1" size="6" who="Chipzz" />
<person posts="1" size="4" who="Pablo Bendersky" />
<person posts="1" size="3" who="Aric Stewart" />
<person posts="1" size="3" who="Sanjay Connare" />
<person posts="1" size="3" who="Michael Stefaniuc" />
<person posts="1" size="3" who="Christian Costa" />
<person posts="1" size="3" who="Boaz Harrosh" />
<person posts="1" size="2" who="(chall)" />
<person posts="1" size="2" who="Marcus Meissner" />
<person posts="1" size="2" who="Saulius Krasuckas" />
<person posts="1" size="2" who="Chuck Hall" />
<person posts="1" size="2" who="Scott Snell" />
<person posts="1" size="2" who="Uwe Bonnes" />
<person posts="1" size="2" who="Kevin Koltzau" />
<person posts="1" size="2" who="Rolf Kalbermatter" />
<person posts="1" size="2" who="Andreas Mohr" />
<person posts="1" size="2" who="Rein Klazes" />
<person posts="1" size="2" who="Brian Vincent" />
<person posts="1" size="2" who="Roderick Colenbrander" />
<person posts="1" size="2" who="Jason Edmeades" />
<person posts="1" size="2" who="Geoffrey Leach" />
<person posts="1" size="1" who="gslink" />
<person posts="1" size="1" who="Todd S." />

</stats>
<section 
	title="News: Wine in the Press" 
	subject="News"
	archive="http://www.winehq.com/hypermail/wine-devel/2004/07/0.html" 
	posts="1"
	startdate="08/21/2004"
	enddate="08/27/2004"
>
<topic>News</topic>
<p>There seems to be an interesting trend going on.. or perhaps it's
just a bunch of weird coincidences.  Over the past month I've noticed
a lot of off-hand references to Wine in a bunch of different sources;
everything from software reviews to mailing lists (besides Wine!) that
I'm subscribed to.  It seems like Wine is appearing on the radar screen
for more and more people.  For example, consider this 
linux.com article that describes using Wine to
<a href="http://www.linux.com/article.pl?sid=04/08/23/1422211">run a Waste
client</a>.  (<a href="http://waste.sourceforge.net/">Waste</a> is a 
P2P app for instant messaging and file transfers incorporating a lot of
encryption.)  The fact that Wine is involved seems more of an afterthought.
Also check out this <a 
href="http://news.independent.co.uk/world/science_technology/story.jsp?story=554736">Linux review</a> that comments, 
<quote who="independent.co.uk">Here's what I need to do next. ... Learn how to
 use Wine - a clever way of running Windows programs under Linux - for my 
 accounts program.</quote> 
 Trend, coincidence, or an editor in search of
 a news story.. you decide.
</p>
</section>
<section
        title="Darwine Update"
        subject="New Darwine Binary Released"
        archive="http://www.winehq.com/hypermail/wine-devel/2004/08/0417.html"
        posts="2"
        startdate="08/20/2004"
        enddate="08/21/2004"
>
<topic>Ports</topic>
<p>The Darwine folks popped up this week to let us know what they're
working on.  It's been quite a few months since we've given an update
on the project (see WWN issue
<a href="http://www.winehq.com/?issue=207#Darwine%20Update">#207</a> for
the last one.)  There's definitely a lot of exciting stuff going on in
that area and it seems like preliminary support for running i386 Windows
binaries on Mac OS X is in place.  A slew of emails hit wine-devel this
week, the first of which was Sanjay Connare's announcement:</p>
<quote who="Sanjay Connare"><p>
 	I am proud and happy to announce the release of a new binary labeled Darwine 20040820 DP.  This binary is based upon the 20040813 wine release.  The majority of changes for this release can be viewed:
	<ul><a href="http://cvs.winehq.org/cvsweb/wine/ChangeLog">
http://cvs.winehq.org/cvsweb/wine/ChangeLog</a></ul></p><p>

	It is being released as a DEVELOPER PREVIEW so USE AT YOUR OWN RISK!  It is not yet suited for mass distribution or general user use.  This release in addition to all of the fixes from the wine team includes many Mac OS X optimizations and fixes.  It also includes WineHelper a native Mac OS X application that helps launch .exe's.  It allows for .exe's to be double clicked in the finder like any other application and essentially bypasses the need to run wine via the command line.
	</p><p>
	The Darwine libraries have been moved from their default installation location of /usr/local to a more Mac OS X friendly location /Library/Darwine.  Applications and WineHelper are installed in /Applications/Darwine.
	</p><p>
	This new binary also automatically uninstalls the previous binary if it is found to be installed.  For uninstall to occur the user must enter an administrator's password. If the correct password is entered the uninstaller will return some errors however the old version of Darwine will be removed and the install of this new binary can commence by reopening the installer package.  A new uninstaller is included with this release that simplifies the uninstall process thanks to the new location of libraries.
	</p><p>
	The binary has been split into two releases one being this release and a soon to be released Darwine SDK.  The Darwine SDK will contain the source for both wine and WineHelper, all of the header files, winegcc, winebuild tools and many examples and scripts that will allow open source apps to be compiled using these tools.
	</p><p>
	 Please report bugs to the darwine SourceForge Bug Tracking System, and to the darwine-devel mailing-list.  Also any comments, questions or concerns can also be posted to the darwine-devel mailing-list.  Enjoy this new release.
	</p></quote>

<p>It looks like the port has really begun to integrate like native Mac OS X apps and seems to be getting some userland attention.  It's also great to see they were able to release a new binary based on the most recent vintage of Wine.  
Jim White followed up on Sanjay's announcement to point out a few other things; not the least of which was a change in the <a href="http://darwine.opendarwin.org/">Darwine website</a> from SourceForge to 
<a href="http://www.opendarwin.org/">OpenDarwin.org</a>.  Jim also provided a link to a recent interview:</p>
<quote who="Jim White"><p>
Other Darwine news is that there was an interview with moi on osViews:
</p><p> 
 Text:
 <ul><a href="http://www.osviews.com/modules.php?op=modload&amp;name=News&amp;file=article&amp;sid=2046">
 http://www.osviews.com/modules.php?op=modload&amp;name=News&amp;file=article&amp;sid=2046</a></ul></p><p>
 
 Broadcast:
 <ul><a href="http://www.osviews.com/modules.php?op=modload&amp;name=News&amp;file=article&amp;sid=2047">
 http://www.osviews.com/modules.php?op=modload&amp;name=News&amp;file=article&amp;sid=2047</a></ul></p>
</quote>

<p>Then Jim mentioned that work with integrating with the QEMU emulator was progressing:</p>
<quote who="Jim White"><p>

And perhaps the most interesting news is that Darwine's lead developer 
Pierre d'Herbemont has successfully ported QEMU (fast X86 emulator) to 
Mac OS X:
<ul><p>
 QEMU on Mac OS X<br />
 by Pierre d'Herbemont<br />
 2004-07-04 at 11:07:13</p><p>
 
 I am proud to announce that <a href="http://bellard.org/qemu">QEMU</a> is now working on Mac OS X.

<ul><li>Original <a href="http://lists.gnu.org/archive/html/qemu-devel/2004-07/msg00008.html">announcement</a> on the qemu-devel list</li>
<li>Download the <a href="http://stegefin.free.fr/qemu/qemu.dmg">installer</a> for Mac OS X</li>
<li><a href="http://www.freeoszoo.org/screenshots.php">Screenshots</a> of QEMU running on Mac OS X</li>
<li>The <a href="http://www.freeoszoo.org/">FreeOSZoo</a>, to download ready-to-run images of QEMU virtual computers, pre-installed with a Free Operating System and a set of popular free software.</li></ul></p><p>
 
 I would like to thanks Matt Reda for its collaboration.</p></ul></p></quote>

<p>Jim has an excellent explanation in the interview linked above about why QEMU
integration is important:</p>
<quote who="osviews.org"><p>
<i>osViews</i>: Why aren't you just porting QEMU and then running Wine through the port of QEMU?
</p><p>
<i>Jim White</i>: QEMU is a processor... um, its a computer emulation... and so it runs 
an operating system. So, QEMU is a virtualization environment. So, its doing that job. 
It already runs Linux... under QEMU that just came to pass this last week or two. 
So Wine would run now under Linux... under QEMU.</p><p>

But that's not what Darwine's about. Darwine is the idea that by incorporating the x86 
emulation with the Wine environment, that we can run applications without running a 
separate operating system.</p><p>[....]</p><p>

The reason that Darwine has a special case [which] could be interesting is... when you 
talk about emulation, then the next question people ask after, 'does it work' is 'well, 
how fast does it go?' So one of the reasons why Darwine... could in the long run be 
worth while is on that issue alone.
</p><p>
The opportunities for optimization are very very high with the Darwine approach 
because the problem that a general processor emulator has is its compilation 
window... Like QUMU compiles instructions... and compiles them into native code 
and runs that, but since it doesn't know things like 'what are code blocks' and 
this sort of thing... it's very limited in what it can do there.... its window 
translating scheme.
</p><p>
But with Darwine, down the road... since we know things like, 'what are code blocks' things could could actually be natively translated. {This allows} a block of code to be compiled in native code and not have to use dynamic compilation at all. Performance could potentially get MUCH better than systems that use operating system virtualization.
</p></quote>

</section>
<section 
	title="Darwine, Wine, &amp; QEMU" 
	subject="X86/PPC linking (was Re: [Darwine] Re: Wine Emulation: Swapping functions)"
	archive="http://www.winehq.com/hypermail/wine-devel/2004/08/0533.html" 
	posts="18"
	startdate="08/24/2004"
	enddate="08/26/2004"
>
<topic>Ports</topic>
<p>Guess this must be the week of Darwine news.. another thread popped up
up about using Wine + QEMU on Mac OS X.  Now, normally a lot of discussion
like this takes place over on the Darwine mailing lists.  Mike Hearn made
a comment that prompted Jim White to explain rude comments were exactly
the reason discussion of Darwine was not done on Wine mailing lists.  
Alexandre, however, encouraged them to use Wine's mailing lists to bounce
ideas off other developers,
<quote who="Alexandre Julliard">
 that's not the general attitude here, you guys are
 very much welcome on wine-devel. So please don't hesitate to CC
 wine-devel on anything that can be of interest, even if it's not
 strictly a Wine issue; this makes it possible for us to catch
 potential problems earlier on, and it helps us to get some context so
 that when you submit a patch we have a better idea of the big picture
 behind the patch.
</quote></p>

<p>That actually seemed to open the floor to some discussion that's not seen 
very often on the list.  In this case it centered around getting Wine to
use QEMU as a CPU-level emulator, but without running a separate operating
system on top of it.  Now, in the interview above Jim alludes to running
Linux on QEMU running on Mac OS X.  Within that sandbox he could also run
Wine.  The "holy grail" seems to be bypassing the need for an operating
system altogether and plugging Wine directly into QEMU.  However, that's
a lot easier said than done; I already have a headache just trying to wrap
my head around it.  I'm probably going to botch this whole summary,
partly because I don't fully understand all the issues and partly because
it seems like some discussion also drifted off-list.  
</p><p>
The first issue that
seemed to pop up involved endian issues.  An x86 machine is considered a 
"little-endian" architecture and a PowerPC is considered "big-endian". 
Now, what that means is if you have something like an integer 
there is a corresponding binary string consisting of a bunch of 1's and 0's.
Let's take a really simple example simplified to the point where the example
is wrong, but the idea is right.  Let's examine what happens to the number
65,534 when it's stored in memory.  First, you can break 65534 down into a
hexadecimal number FFFE, or in hex notation 0xFFFE.  Now, the geeks among you 
(and judging from this 
audience it's probably most of you) will truly recognize that for what it
is - two bytes of information.  (For the sake of this discussion we won't
get into the fact that the bytes 0xFFFE can be represented as binary bits;
namely, 11111111 11111110.)  
</p><p>
Up to this point the whole world of mathematics and computer
science agrees on everything.  Things begin to fall apart when we need to
store these bytes in computer memory.  Now, on both big-endian and little-endian
architectures each memory location addresses 1 byte. How these memory 
locations are assigned differs though.  On a big-endian machine (PPC) the
most significant byte (in this case, 0xFF) is stored at a memory location 
with the lowest address,
the next most significant byte (0xFE) is stored in the next address, etc.  So 
if you were to look at a chunk of memory in sequential order you would just see
FF FE stored there.  If you move over to
a little-endian machine it's different (not really more complicated.. just
differently complicated).  There we store the least significant byte in
the first memory location.  So if you were to look at that same sequence of
memory on a little-endian machine you'd see "FE FF" stored there.  What
we mean by "look" is something like, grab a pointer to an address in memory and
then keep indexing it until we've sucked in all the data we want.  What
got sucked in?  Well.. as you can see.. it depends on the endianess.  Now,
we've used a primitive example of a 16-bit integer.  Things get worse when
you consider a 32-bit architecture and how something like a string of 
characters might get misinterpreted.
</p><p>
Now, what the Darwine guys want to do is take a Windows 
executable compiled for a little-endian machine (x86), run it through 
Wine, and then into QEMU to make sure the instructions are translated 
properly into big-endian PPC commands.  Ouch.. makes.. head.. hurt.. Mike 
pointed out just one potential problem:</p>
<quote who="Mike Hearn"><p>
 what I meant by that statement is that if you're running x86 
 Wine in QEMU you can't access the Carbon APIs directly. I think in the 
 mode where you run foreign binaries QEMU will perform syscall conversion 
 but obviously this is of limited use - the OS X APIs aren't accessible 
 via syscalls.
</p><p> 
 One thing you could do I guess is expose each OS X API that you wanted 
 as a new "fake" syscall and then use a customized version of QEMU that 
 converted it into a Mac API call, ie marshal the calls in and out of the 
 emulated environment. You'd still pay a performance penalty but that's 
 unavoidable. I'm not sure how you'd deal with callbacks.
</p></quote>

<p>Jim White had a different idea to deal with that problem:</p>
<quote who="Jim White"><p>
 
The ideal method would be to handle this with a trick loader that can 
link to PPC code which is escaped from the X86 emulation.  We can 
automatically generate X86 DLLs for the PPC dynamic libraries (and hence 
the OS X APIs) which have little emulation escape thunks in them.  There 
is zero performance penalty since the emulator can compile such escapes 
as direct native calls.  Callbacks use a similar sort of little thunk 
which calls the emulator with a given X86 address.
</p><p>
I would really like to get away from having to write all the little 
wrappers to deal with the namespace problem.  I believe we can solve 
that with a suitable naming convention as we began to do with the 
winegcc patch.
</p><p>
Alternatively we could go with dynamic binding as proposed by 
Alexandre and have a syscall (or emulation escape) to call PPC code. 
This is probably the easiest to implement but leaves us with extra call 
overhead (although apparently this is something that is currently done 
in Wine and is quite small).
</p><p>
By using suitable macros we can make the source independent of which 
method is used.
</p><p>
The thing we don't get away from is that any code which calls OS X 
routines from X86 code *will* have to deal with endianess.  There is 
overhead here, but we can be careful to use code that the emulator does 
a good job translating.  Of course if there is substantial code (which 
would be unusual) it can simply be compiled as a PPC dynamic library.
</p><p>
As for swapping functions, the preceding discussion reiterates my belief 
that we should confine such fussy business to the relatively small bit 
of code that calls into OS X, will be relatively stable over the long 
haul, and over which we have full control.  And as for the concern over 
having Wine be X86 and hence incurring emulation overhead, this would be 
one of the first bits of code which would be a candidate for having its 
emulator-compiled code cached.
</p></quote>

<p>Now, part of the reason I included that snippet of  discussion is to 
outline some of the complex things that need to be dealt with.  The actual 
thread put forth a roadmap of what the Darwine guys want to do that's much 
easier to understand:

<ul><li>As a first step, Wine will be compiled as an x86 executable,
and hence match the executable it's trying to run.</li>
<li>In turn, the version of QEMU to be used will be qemu-darwin-i386-user,
which is a special "user mode" version of QEMU that can run something like
the x86 version of Wine without emulating a full-blown PC (such as required
by something like an operating system.)  </li>
<li>From there it would be nice to figure out a way to integrate QEMU
into Wine and figure out a way to generate a wrapper to convert Win32 calls.
</li>
</ul></p>

<p>Lofty goals?  Perhaps.  However, given the number of porting ideas that
have fallen by the wayside and given how far Darwine has come.. maybe
these guys can pull it off.  Special thanks to Pierre d'Herbemont for
reviewing this thread, no thanks to me for making a bunch of changes after
that.</p>

</section>
<section
        title="Quartz Display Driver"
        subject="Beginnings of quartzdrv"
        archive="http://www.winehq.com/hypermail/wine-devel/2004/08/0440.html"
        posts="8"
        startdate="08/22/2004"
        enddate="08/23/2004"
>
<topic>Ports</topic>
<p>And finally in Darwine/Mac OS X news, Rib Rdb announced a new Wine display
driver to work with Quartz.  On Mac OS X, Quartz is the low-level 2D
graphics rendering library upon which the Aqua desktop is built and
apps integrating with it provide a common look and feel.  Apps that
don't integrate with it, such as native X applications, seem out
of place.  Currently Wine supports two main display drivers - one
is for graphical apps using X (x11drv) and the other is for commandline
apps (ttydrv.)  There have been efforts in the past to add others,
such as the SDL driver (see WWN issue
<a href="{$root}/site/?issue=114#New%20SDL%20Driver">#114</a>), 
but there hasn't been much of a reason.  Rib explained that there's still much 
work to do in order for the driver to be functional:</p>
<quote who="Rib Rdb"><p>
Attached is a very preliminary driver for native graphics on OS X.  So
far all it does is let you make windows.  No events or drawing work
yet (I was baffled by the GetDC function. It looked like the existing
drivers only call windows functions, and I didn't see any way for
setting the window's context.)  To compile this requires a patch by
Pierre d'Herbemont to deal with conflicting function names in windows
and Carbon.  He said he will send it here.
Also, to get the windows to focus, you have to place the executable in
an application bundle.  I just took one I had sitting around, copied
the wine binary over the executable in the bundle and ran it from the
commandline like so:
<ul>
<tt>/Users/ribrdb/Desktop/winemine.app/Contents/MacOS/CarbonTest winemine</tt></ul></p><p>

Things are getting busy with work, so I'm not sure when I'll have more
time to work on this.</p></quote>

<p>Mike Hearn wondered if the effort was really worth it,
<quote who="Mike Hearn">
Given the complexity and amount of work done on the x11drv it 
seems silly to duplicate all that effort. The x11drv is worked on by the 
entire Wine development team right now, so any quartzdrv would always be 
playing catchup. Well, if they want to spend their time doing that, fine 
by me</quote></p>

<p>Lionel Ulmer disagreed and thought it could be a valuable exercise:</p>
<quote who="Lionel Ulmer">
<p>
Well, by 'the entire Wine development team' you mean Alexandre :-) ?
</p><p>
I, for one, am happy that people are using our driver model to write new
drivers as it could serve as a proof of concept that our driver model is
sound (think about GL / Cairo / 'DBI engine' kind of drivers).... Heck, if
we only wanted to support one driver, why do all the job of doing a clean
separation and not include X11 in Wine's GDI directly ?</p></quote>

<p>Mike pointed out that there were other people besides Alexandre that
had recently contributed to the X driver.  He went on to explain 
that the driver model has already proven to be sound:</p>
<quote who="Mike Hearn">
<p>Well the driver model is lifted from Windows so I think it is sound. And 
as for why we use separate drivers, well, when the DLL separation is 
complete it means we can make a real Windows box display via X11 which 
is Just Plain Cool :)
</p><p>
It also allows for portability to operating systems that don't have X11. 
Mac OS X <i>does</i> have X, in fact it's a modified XFree but with some 
proprietary bits added. So I'm thinking the added effort is not worth 
the gain. I'm not a Mac user though so who knows, maybe the extra 
native-ness is worth all the pain </p></quote>

<p>Some discussion then moved over to irc and the debate was rehashed.  
</p>

</section>

<section 
    	title="Unicode to ASCII Crosscalls Suck More" 
	subject="Other W-&gt;A crosscalls"
	archive="http://www.winehq.com/hypermail/wine-devel/2004/08/0527.html" 
	posts="4"
	startdate="08/25/2004"
>
<topic>Internationalization</topic>
<p>From time to time we point to the
<a href="http://www.winehq.com/site/janitorial">Wine Janitorial page</a> and 
<a href="http://www.winehq.com/site/fun_projects">Fun Projects list</a> 
as a good way for aspiring developers to get involved. <i>hint, hint</i>
One of those janitorial tasks is to prevent Unicode functions from 
using ASCII functions to do their dirty work.. and in the process perform a 
lossy conversion.  Well, that list is definitely shrinking thanks to a lot
of individuals and some of the things left on the list seem harder than others
to finish.  We generated the list of cross-calls (or "Wide to ASCII" aka 
"W-&gt;A")
using a little tool Patrik Stridvall wrote years ago called 
<tt>winapi_check</tt>.  Vincent B&#233;ron decided to point out this week
that.. <i>oops</i>.. we're probably wrong about how complete that list is. 
In fact, it's not like we're a little wrong.. we seem to have missed a
bunch:</p>

<quote who="Vincent Beron"><p>
I played a bit with smatch and Wine (after reading
<a href="http://people.redhat.com/mstefani/wine/smatch/">http://people.redhat.com/mstefani/wine/smatch/</a>),
to try to get over what I mentionned in my last email (regarding winapi_check 
and cross-calls in parenthesis).
</p><p>
I attach the smatch script to generate the results I have. It's still
not perfect (the listview.c references are wrong, for example), but as
it's tied to gcc it can detect some calls which otherwise would not be
caught. For example, the calls to GetWindowLongA in header.c are in a
macro.
</p><p>
Not all of them are bugs: caution is needed when checking, although
reducing the number of false positive would likely be welcome (either by
modifying the script or patches).
</p></quote>

<p>The 
<a href="http://www.winehq.com/hypermail/wine-devel/2004/08/0527.html">list</a>
was quite lengthy with 286 possible cases. Compare that to the 54 we list on
the janitorial page and it looks as if we haven't even started.  Rob Shearman
pointed out the latest CVS might contain less since a very recent patch
corrected calls to GetWindowLongA.  Vincent reran the test and found things
improved!  We dropped to 270!  (Sorry, I just got done watching <i>The Daily
Show</i>, so pretend Jon Stewart is reading this paragraph out loud.)  Rolf
Kalbermatter did point out that calls in the shell related DLLs might not
be a problem.  In a different thread, Vincent described how this has been
overlooked:</p>
<quote who="Vincent Beron"><p>
Also take note (Francois? Any perl hacker?) that the method used to find
the cross-calls (winapi_check) is not 100% proof. There are some valid C
statements which contain a cross-call which are not found. Look at
dlls/lzexpand/lzexpand_main.c GetExpandedNameW:
<ul><code>
INT WINAPI GetExpandedNameW( LPWSTR in, LPWSTR out )<br />
{<br />
    &#160;INT ret;<br />
    &#160;DWORD len = WideCharToMultiByte( CP_ACP, 0, in, -1, NULL, 0, NULL,
NULL );<br />
    &#160;char *xin = HeapAlloc( GetProcessHeap(), 0, len );<br />
    &#160;char *xout = HeapAlloc( GetProcessHeap(), 0, len+3 );<br />
    &#160;WideCharToMultiByte( CP_ACP, 0, in, -1, xin, len, NULL, NULL );<br />
    &#160;if ((ret = GetExpandedNameA( xin, xout )) &gt; 0)<br />
    &#160;&#160;&#160;&#160;&#160;MultiByteToWideChar( CP_ACP, 0, xout, -1, out, strlenW(in)+4 );<br />
    &#160;HeapFree( GetProcessHeap(), 0, xin );<br />
    &#160;HeapFree( GetProcessHeap(), 0, xout );<br />
    &#160;return ret;<br />
}</code></ul></p><p>

The A call is between parenthesis and winapi_check can't find it.
winapi_check would need to be modified to find those, as I'm sure that's
not the only one in the whole tree.
</p></quote>

<p>Everyone promptly ignored the thread and forgot they had ever read it.</p>
 
</section>
<section 
	title="poll vs. epoll (con't)" 
	subject="Non-perfect epoll patch"
	archive="http://www.winehq.com/hypermail/wine-devel/2004/08/0492.html" 
	posts="4"
	startdate="08/24/2004"
	enddate="08/26/2004"
>
<topic>IO</topic>
<topic>Architecture</topic>
<p>Last week we covered Shachar Shemesh's inquiry into using epoll() instead
of poll() (see WWN 
<a href="http://www.winehq.com/?issue=236#poll%20vs.%20epoll">#236</a>.)
Well, Shachar took a stab at the idea presented and returned this week
with a patch:</p>
<quote who="Shachar Shemesh"><p>
Attached is a 
<a href="http://www.winehq.com/hypermail/wine-devel/2004/08/0492.html">non-perfect
patch</a> for review. This is a migration of the 
wineserver to use epoll instead of poll (if it's available).
</p><p>
current known issue with this patch:
<ol>
<li> Will not compile if HAVE_SYS_EPOLL_H is not 1 (i.e. - won't compile 
if epoll not available at compile time)</li>
<li> Segfaults on wine exit.</li>
<li> Lots of debug asserts.</li></ol></p><p>
Comments welcome.</p></quote>

<p> Mike McCormack did offer some suggestions:</p> 
<quote who="Mike McCormack"><p>
If you're going to use syscalls instead of epoll_create etc, then you 
don't need to check whether epoll functions exist in glibc, since you're 
not using them anyway.
</p><p>
In any case, seeing that getting your patch accepted will take some 
effort, it's probably a good idea to use the glibc version functions 
first, and deal with the problem of missing epoll functions in older 
glibcs in a separate patch.</p></quote>

<p>Shachar ran some benchmarks and posted the results:</p>
<quote who="Shachar Shemesh"><p>
The patch is not yet ready for commit, but I do have preliminary benchmarks:
The attached program (compiled as winelib) was used. ulimit -n was 
raised to 10240.</p><p>
With the current wine code:
<ul>real    0m41.076s<br />
user    0m5.070s<br />
sys     0m7.722s</ul>
</p><p>
the main wine process was taking 10% CPU time, and wineserver was taking 
over 60% cpu time. load average was over 2
</p><p>
With my preliminary path:
<ul>
real    0m20.985s<br />
user    0m5.316s<br />
sys     0m11.421s</ul></p><p>
main wine process was still taking 10%, but so was wineserver. load 
average was about 1.5.
</p><p>
We can see that there is a significant drop in actual execution time, 
even though there is an INCREASE in user+system processing time. I 
believe this is not a fluke (results are pretty consistent), but rather 
that the poll behavior was taking a huge toll on the system in areas 
where it wasn't attributed towards wine, even though it was wine 
related. I would take the real time measurement as the indicative one.
</p><p>
Ideas for better benchmarks would be greatly appreciated.
</p></quote>
</section></kc> 
